<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WhisperLiveKit Debug Tool</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .status { margin: 10px 0; padding: 10px; border-radius: 5px; }
        .success { background-color: #d4edda; color: #155724; }
        .error { background-color: #f8d7da; color: #721c24; }
        .warning { background-color: #fff3cd; color: #856404; }
        .info { background-color: #d1ecf1; color: #0c5460; }
        button { padding: 10px 20px; margin: 5px; }
        #log { background: #f8f9fa; padding: 10px; border: 1px solid #dee2e6; height: 300px; overflow-y: auto; }
    </style>
</head>
<body>
    <h1>üîç WhisperLiveKit –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞</h1>
    
    <div id="browser-check" class="status info">–ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É –±—Ä–∞—É–∑–µ—Ä–∞...</div>
    <div id="microphone-check" class="status info">–ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É...</div>
    <div id="websocket-check" class="status info">–ü—Ä–æ–≤–µ—Ä—è–µ–º WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ...</div>
    <div id="audio-check" class="status info">–ü—Ä–æ–≤–µ—Ä—è–µ–º –∞—É–¥–∏–æ –∫–æ–¥–µ–∫–∏...</div>
    
    <button onclick="testMicrophone()">–¢–µ—Å—Ç –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞</button>
    <button onclick="testWebSocket()">–¢–µ—Å—Ç WebSocket</button>
    <button onclick="testFullFlow()">–ü–æ–ª–Ω—ã–π —Ç–µ—Å—Ç</button>
    
    <h3>–õ–æ–≥:</h3>
    <div id="log"></div>

    <script>
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `<div style="color: ${type === 'error' ? 'red' : type === 'success' ? 'green' : 'black'}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        function updateStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `status ${type}`;
        }

        // Check browser support
        function checkBrowserSupport() {
            const checks = [
                { name: 'MediaDevices API', test: () => navigator.mediaDevices },
                { name: 'WebSocket', test: () => window.WebSocket },
                { name: 'MediaRecorder', test: () => window.MediaRecorder },
                { name: 'AudioContext', test: () => window.AudioContext || window.webkitAudioContext }
            ];

            let allSupported = true;
            checks.forEach(check => {
                if (check.test()) {
                    log(`‚úì ${check.name} –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è`, 'success');
                } else {
                    log(`‚úó ${check.name} –ù–ï –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è`, 'error');
                    allSupported = false;
                }
            });

            updateStatus('browser-check', 
                allSupported ? '‚úì –ë—Ä–∞—É–∑–µ—Ä –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≤—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ API' : '‚úó –ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ API',
                allSupported ? 'success' : 'error'
            );
        }

        // Test microphone access
        async function testMicrophone() {
            try {
                log('–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É...');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                log('‚úì –î–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –ø–æ–ª—É—á–µ–Ω', 'success');
                
                // Test audio levels
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioContext.createAnalyser();
                const microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                let maxLevel = 0;
                
                const checkAudio = () => {
                    analyser.getByteFrequencyData(dataArray);
                    const level = Math.max(...dataArray);
                    maxLevel = Math.max(maxLevel, level);
                };
                
                const interval = setInterval(checkAudio, 100);
                
                setTimeout(() => {
                    clearInterval(interval);
                    stream.getTracks().forEach(track => track.stop());
                    audioContext.close();
                    
                    if (maxLevel > 10) {
                        log(`‚úì –ê—É–¥–∏–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ (–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å: ${maxLevel})`, 'success');
                        updateStatus('microphone-check', '‚úì –ú–∏–∫—Ä–æ—Ñ–æ–Ω —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ', 'success');
                    } else {
                        log(`‚ö† –ê—É–¥–∏–æ —Å–∏–≥–Ω–∞–ª —Å–ª–∞–±—ã–π –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç (–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å: ${maxLevel})`, 'warning');
                        updateStatus('microphone-check', '‚ö† –ú–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ —É–ª–∞–≤–ª–∏–≤–∞–µ—Ç –∑–≤—É–∫', 'warning');
                    }
                }, 3000);
                
                log('–ì–æ–≤–æ—Ä–∏—Ç–µ –≤ –º–∏–∫—Ä–æ—Ñ–æ–Ω –≤ —Ç–µ—á–µ–Ω–∏–µ 3 —Å–µ–∫—É–Ω–¥...');
                
            } catch (error) {
                log(`‚úó –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É: ${error.message}`, 'error');
                updateStatus('microphone-check', '‚úó –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É', 'error');
            }
        }

        // Test WebSocket connection
        async function testWebSocket() {
            const wsUrl = 'ws://localhost:8000/asr';
            log(`–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ WebSocket: ${wsUrl}`);
            
            try {
                const ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    log('‚úì WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ', 'success');
                    updateStatus('websocket-check', '‚úì WebSocket —Ä–∞–±–æ—Ç–∞–µ—Ç', 'success');
                    
                    // Send test message
                    const testBlob = new Blob(['test'], { type: 'audio/webm' });
                    ws.send(testBlob);
                    log('–û—Ç–ø—Ä–∞–≤–ª–µ–Ω —Ç–µ—Å—Ç–æ–≤—ã–π –∞—É–¥–∏–æ –±–ª–æ–∫');
                };
                
                ws.onmessage = (event) => {
                    log(`–ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞: ${event.data}`, 'success');
                };
                
                ws.onerror = (error) => {
                    log(`‚úó WebSocket –æ—à–∏–±–∫–∞: ${error}`, 'error');
                    updateStatus('websocket-check', '‚úó WebSocket –æ—à–∏–±–∫–∞', 'error');
                };
                
                ws.onclose = (event) => {
                    if (event.wasClean) {
                        log('WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ');
                    } else {
                        log(`‚úó WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø—Ä–µ—Ä–≤–∞–Ω–æ (–∫–æ–¥: ${event.code})`, 'error');
                        updateStatus('websocket-check', '‚úó WebSocket –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç', 'error');
                    }
                };
                
                // Close after 5 seconds
                setTimeout(() => {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.close();
                    }
                }, 5000);
                
            } catch (error) {
                log(`‚úó –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å WebSocket: ${error.message}`, 'error');
                updateStatus('websocket-check', '‚úó WebSocket –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω', 'error');
            }
        }

        // Test audio codecs
        function testAudioCodecs() {
            const recorder = window.MediaRecorder;
            if (!recorder) {
                updateStatus('audio-check', '‚úó MediaRecorder –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω', 'error');
                return;
            }

            const codecs = ['audio/webm', 'audio/webm;codecs=opus', 'audio/webm;codecs=vp8', 'audio/mp4'];
            const supported = [];
            
            codecs.forEach(codec => {
                if (MediaRecorder.isTypeSupported(codec)) {
                    supported.push(codec);
                    log(`‚úì –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è: ${codec}`, 'success');
                } else {
                    log(`‚úó –ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è: ${codec}`, 'warning');
                }
            });

            if (supported.length > 0) {
                updateStatus('audio-check', `‚úì –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è –∫–æ–¥–µ–∫–∏: ${supported.join(', ')}`, 'success');
            } else {
                updateStatus('audio-check', '‚úó –ù–µ—Ç –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö –∞—É–¥–∏–æ –∫–æ–¥–µ–∫–æ–≤', 'error');
            }
        }

        // Full test
        async function testFullFlow() {
            log('=== –ù–∞—á–∏–Ω–∞–µ–º –ø–æ–ª–Ω—ã–π —Ç–µ—Å—Ç ===');
            checkBrowserSupport();
            testAudioCodecs();
            await new Promise(resolve => setTimeout(resolve, 1000));
            await testMicrophone();
            await new Promise(resolve => setTimeout(resolve, 1000));
            await testWebSocket();
            log('=== –¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω ===');
        }

        // Run initial checks
        window.onload = () => {
            checkBrowserSupport();
            testAudioCodecs();
        };
    </script>
</body>
</html>